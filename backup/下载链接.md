## 获取链接
```
const links = document.getElementsByTagName('a');

// 遍历所有链接并查找匹配 Hugging Face blob 地址
for (const link of links) {
  const href = link.href;
  // 匹配 datasets 仓库 blob 链接
  const urlRegex = /^https:\/\/huggingface\.co\/datasets\/[^/]+\/[^/]+\/blob\/[^/]+\/.+$/;
  if (urlRegex.test(href)) {
    // 替换 blob → resolve
    const realUrl = href.replace("/blob/", "/resolve/");
    console.log("直链: " + realUrl);
  }
}
```

## 执行下载

```
# -*- coding: utf-8 -*-
"""
auto_paste_two_options.py
两个选项：
1) 开始：进入坐标获取界面 → F5 保存坐标后自动开始循环
0) 退出

循环逻辑：
- 从 TXT 每行读取
- 点击输入框 → 粘贴 → 回车(或点击按钮)
- 间隔 N 秒继续
"""

import os, sys, json, time, subprocess

# ===== 依赖自动安装 =====
def ensure_packages():
    for p in ["pyautogui", "keyboard", "pyperclip"]:
        try:
            __import__("pyautogui" if p=="pyautogui" else p)
        except Exception:
            print(f"[安装] 缺少 {p}，正在安装...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", p])
ensure_packages()

import pyautogui, keyboard, pyperclip

pyautogui.FAILSAFE = True
pyautogui.PAUSE = 0.03

CONFIG_FILE = "auto_paste_config.json"
STATE_FILE  = "auto_paste_state.json"

# ===== 这里按需改默认值 =====
DEFAULT_CONFIG = {
    "txt_file": r"c:\Users\Puck\Desktop\sid.txt",   # ← 改成你的 txt 路径
    "coords": {"click_target": None, "submit_btn": None},
    "interval_sec": 180,                  # 间隔秒（3分钟）
    "clear_before_paste": True,           # 粘贴前 Ctrl+A 清空
    "press_enter_after_paste": True       # True=回车提交；False=点击 submit_btn
}

# ========== 工具函数 ==========
def load_json(path, default=None):
    if os.path.exists(path):
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    return default

def save_json(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def get_conf():
    conf = load_json(CONFIG_FILE, None)
    if conf is None:
        conf = DEFAULT_CONFIG.copy()
        save_json(CONFIG_FILE, conf)
    else:
        # 补齐字段
        for k, v in DEFAULT_CONFIG.items():
            if k not in conf: conf[k] = v
        if "coords" not in conf or not isinstance(conf["coords"], dict):
            conf["coords"] = {"click_target": None, "submit_btn": None}
        conf["coords"].setdefault("click_target", None)
        conf["coords"].setdefault("submit_btn", None)
        save_json(CONFIG_FILE, conf)
    return conf

def click(xy):
    if not xy: return
    x, y = xy
    pyautogui.moveTo(x, y, duration=0.05)
    pyautogui.click()

def paste_text(text, clear_before=True):
    if clear_before:
        pyautogui.hotkey("ctrl", "a"); time.sleep(0.05)
    pyperclip.copy(text); time.sleep(0.05)
    pyautogui.hotkey("ctrl", "v")

def press_enter():
    pyautogui.press("enter")

def human_time(sec):
    m, s = divmod(int(sec), 60)
    h, m = divmod(m, 60)
    if h: return f"{h}小时{m}分{s}秒"
    if m: return f"{m}分{s}秒"
    return f"{s}秒"

def countdown(total_sec):
    start = time.time()
    paused = False
    while True:
        if keyboard.is_pressed("esc"):
            print("\n[退出] ESC 触发，结束循环。"); return "abort"
        if keyboard.is_pressed("f8"):
            paused = not paused
            print("\n[状态] " + ("已暂停（F8继续）" if paused else "继续运行"))
            time.sleep(0.5)
        if not paused:
            remain = total_sec - (time.time() - start)
            if remain <= 0: break
            print(f"\r下一次在 {human_time(remain)} 后开始（F8暂停 / ESC退出）", end="", flush=True)
            time.sleep(0.25)
        else:
            print("\r已暂停（F8继续 / ESC退出）     ", end="", flush=True)
            time.sleep(0.25)
    print("\r倒计时完成，继续...               ")

# ========== 循环执行 ==========
def start_loop():
    conf = get_conf()
    click_target = conf["coords"]["click_target"]
    submit_btn   = conf["coords"]["submit_btn"]
    txt_path     = conf["txt_file"]
    interval     = int(conf["interval_sec"])
    clear_before = bool(conf["clear_before_paste"])
    use_enter    = bool(conf["press_enter_after_paste"])

    if not click_target:
        print("[错误] 未设置输入框坐标，请先选择‘开始’，在获取坐标界面按 F6 记录并 F5 保存。")
        return
    if not txt_path or not os.path.exists(txt_path):
        print(f"[错误] 找不到 txt 文件：{txt_path}")
        return
    if not use_enter and not submit_btn:
        print("[提示] 未设置提交按钮坐标，改用回车提交。")
        conf["press_enter_after_paste"] = True
        save_json(CONFIG_FILE, conf)
        use_enter = True

    state = load_json(STATE_FILE, {"last_index": -1})
    last_idx = int(state.get("last_index", -1))

    # 读取 txt（跳过空行/注释）
    with open(txt_path, "r", encoding="utf-8") as f:
        items = []
        for line in f:
            s = line.strip()
            if not s or s.startswith("#") or s.startswith("//") or s.startswith(";"): continue
            items.append(s)
    if not items:
        print("[提示] 文本文件为空（或仅注释/空行）。"); return

    print("=== 循环开始 ===")
    print(f"[信息] 待处理 {len(items)} 条。从第 {last_idx + 2} 条开始。")
    print("运行中快捷键：F8 暂停/继续，ESC 退出\n")

    try:
        for idx, text in enumerate(items):
            if idx <= last_idx: continue
            print(f"\n▶️ 第 {idx+1}/{len(items)} 条：{text}")

            click(click_target); time.sleep(0.08)
            paste_text(text, clear_before=clear_before); time.sleep(0.08)

            if use_enter:
                press_enter()
            else:
                click(submit_btn)

            save_json(STATE_FILE, {"last_index": idx})
            print(f"[进度] 已保存 last_index = {idx}")

            result = countdown(interval)
            if result == "abort": break

        print("\n[完成] 已处理到文件末尾。")
    except pyautogui.FailSafeException:
        print("\n[安全停止] 鼠标移至左上角，脚本已停止。")
    except KeyboardInterrupt:
        print("\n[退出] 用户中断。")

# ========== 获取坐标（F5 保存并直接开跑） ==========
def get_coords_then_run():
    conf = get_conf()
    coords = conf["coords"]
    print("=== 获取坐标模式 ===")
    print("F6 = 记录输入框坐标（click_target）")
    print("F7 = 记录提交按钮坐标（submit_btn，可选；留空则用回车）")
    print("F5 = 保存坐标并立刻开始循环")
    print("ESC= 放弃并返回菜单\n")

    try:
        while True:
            x, y = pyautogui.position()
            print(f"\r当前鼠标：X={x:4d}  Y={y:4d}  ", end="", flush=True)

            if keyboard.is_pressed("f6"):
                coords["click_target"] = [x, y]
                print(f"\n[记录] click_target = {coords['click_target']}"); time.sleep(0.3)
            if keyboard.is_pressed("f7"):
                coords["submit_btn"] = [x, y]
                print(f"\n[记录] submit_btn   = {coords['submit_btn']}"); time.sleep(0.3)

            if keyboard.is_pressed("f5"):
                conf["coords"] = coords
                save_json(CONFIG_FILE, conf)
                print(f"\n[保存] 坐标已写入 {CONFIG_FILE}，即将开始循环…")
                time.sleep(0.6)
                start_loop()
                break

            if keyboard.is_pressed("esc"):
                print("\n[退出] 放弃本次设置，返回菜单。")
                break

            time.sleep(0.05)
    except KeyboardInterrupt:
        print("\n[退出] 用户中断。")

# ========== 菜单 ==========
def main():
    while True:
        print("\n===== Auto Paste (2 选项) =====")
        print("1) 开始（先取坐标 → F5 保存 → 立刻循环）")
        print("0) 退出")
        choice = input("请选择：").strip()
        if choice == "1":
            get_coords_then_run()
        elif choice == "0":
            print("再见！"); break
        else:
            print("无效选择，请重试。")

if __name__ == "__main__":
    main()
```